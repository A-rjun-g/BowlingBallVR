{
  "version": 3,
  "sources": ["../../../dev/gui/src/3D/vector3WithInfo.ts", "../../../dev/gui/src/3D/controls/control3D.ts", "../../../dev/gui/src/3D/controls/container3D.ts", "../../../dev/gui/src/3D/gui3DManager.ts"],
  "sourcesContent": ["import { Vector3 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Class used to transport Vector3 information for pointer events\r\n */\r\nexport class Vector3WithInfo extends Vector3 {\r\n    /**\r\n     * Creates a new Vector3WithInfo\r\n     * @param source defines the vector3 data to transport\r\n     * @param buttonIndex defines the current mouse button index\r\n     */\r\n    public constructor(\r\n        source: Vector3,\r\n        /** defines the current mouse button index */\r\n        public buttonIndex: number = 0\r\n    ) {\r\n        super(source.x, source.y, source.z);\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { IBehaviorAware, Behavior } from \"core/Behaviors/behavior\";\r\nimport type { IDisposable, Scene } from \"core/scene\";\r\n\r\nimport type { GUI3DManager } from \"../gui3DManager\";\r\nimport { Vector3WithInfo } from \"../vector3WithInfo\";\r\nimport type { Container3D } from \"./container3D\";\r\n\r\nimport type { TouchButton3D } from \"./touchButton3D\";\r\n\r\n/**\r\n * Class used as base class for controls\r\n */\r\nexport class Control3D implements IDisposable, IBehaviorAware<Control3D> {\r\n    private _node: Nullable<TransformNode>;\r\n    private _downCount = 0;\r\n    private _enterCount = -1;\r\n    private _downPointerIds: { [id: number]: number } = {}; // Store number of pointer downs per ID, from near and far interactions\r\n\r\n    protected _isVisible = true;\r\n\r\n    /** @internal */\r\n    public _host: GUI3DManager;\r\n    /** @internal */\r\n    public _isScaledByManager = false;\r\n\r\n    /** Gets or sets the control position in world space */\r\n    public get position(): Vector3 {\r\n        if (!this._node) {\r\n            return Vector3.Zero();\r\n        }\r\n\r\n        return this._node.position;\r\n    }\r\n\r\n    public set position(value: Vector3) {\r\n        if (!this._node) {\r\n            return;\r\n        }\r\n\r\n        this._node.position = value;\r\n    }\r\n\r\n    /** Gets or sets the control scaling in world space */\r\n    public get scaling(): Vector3 {\r\n        if (!this._node) {\r\n            return new Vector3(1, 1, 1);\r\n        }\r\n\r\n        return this._node.scaling;\r\n    }\r\n\r\n    public set scaling(value: Vector3) {\r\n        if (!this._node) {\r\n            return;\r\n        }\r\n\r\n        this._isScaledByManager = false;\r\n        this._node.scaling = value;\r\n    }\r\n\r\n    /** Callback used to start pointer enter animation */\r\n    public pointerEnterAnimation: () => void;\r\n    /** Callback used to start pointer out animation */\r\n    public pointerOutAnimation: () => void;\r\n    /** Callback used to start pointer down animation */\r\n    public pointerDownAnimation: () => void;\r\n    /** Callback used to start pointer up animation */\r\n    public pointerUpAnimation: () => void;\r\n\r\n    /**\r\n     * An event triggered when the pointer moves over the control\r\n     */\r\n    public onPointerMoveObservable = new Observable<Vector3>();\r\n\r\n    /**\r\n     * An event triggered when the pointer moves out of the control\r\n     */\r\n    public onPointerOutObservable = new Observable<Control3D>();\r\n\r\n    /**\r\n     * An event triggered when the pointer taps the control\r\n     */\r\n    public onPointerDownObservable = new Observable<Vector3WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when pointer is up\r\n     */\r\n    public onPointerUpObservable = new Observable<Vector3WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when a control is clicked on (with a mouse)\r\n     */\r\n    public onPointerClickObservable = new Observable<Vector3WithInfo>();\r\n\r\n    /**\r\n     * An event triggered when pointer enters the control\r\n     */\r\n    public onPointerEnterObservable = new Observable<Control3D>();\r\n\r\n    /**\r\n     * Gets or sets the parent container\r\n     */\r\n    public parent: Nullable<Container3D>;\r\n\r\n    // Behaviors\r\n    private _behaviors = new Array<Behavior<Control3D>>();\r\n\r\n    /**\r\n     * Gets the list of attached behaviors\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     */\r\n    public get behaviors(): Behavior<Control3D>[] {\r\n        return this._behaviors;\r\n    }\r\n\r\n    /**\r\n     * Attach a behavior to the control\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     * @param behavior defines the behavior to attach\r\n     * @returns the current control\r\n     */\r\n    public addBehavior(behavior: Behavior<Control3D>): Control3D {\r\n        const index = this._behaviors.indexOf(behavior);\r\n\r\n        if (index !== -1) {\r\n            return this;\r\n        }\r\n\r\n        behavior.init();\r\n        const scene = this._host.scene;\r\n        if (scene.isLoading) {\r\n            // We defer the attach when the scene will be loaded\r\n            scene.onDataLoadedObservable.addOnce(() => {\r\n                behavior.attach(this);\r\n            });\r\n        } else {\r\n            behavior.attach(this);\r\n        }\r\n        this._behaviors.push(behavior);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an attached behavior\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     * @param behavior defines the behavior to attach\r\n     * @returns the current control\r\n     */\r\n    public removeBehavior(behavior: Behavior<Control3D>): Control3D {\r\n        const index = this._behaviors.indexOf(behavior);\r\n\r\n        if (index === -1) {\r\n            return this;\r\n        }\r\n\r\n        this._behaviors[index].detach();\r\n        this._behaviors.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets an attached behavior by name\r\n     * @param name defines the name of the behavior to look for\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors\r\n     * @returns null if behavior was not found else the requested behavior\r\n     */\r\n    public getBehaviorByName(name: string): Nullable<Behavior<Control3D>> {\r\n        for (const behavior of this._behaviors) {\r\n            if (behavior.name === name) {\r\n                return behavior;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the control is visible */\r\n    public get isVisible(): boolean {\r\n        return this._isVisible;\r\n    }\r\n\r\n    public set isVisible(value: boolean) {\r\n        if (this._isVisible === value) {\r\n            return;\r\n        }\r\n\r\n        this._isVisible = value;\r\n\r\n        const mesh = this.mesh;\r\n        if (mesh) {\r\n            mesh.setEnabled(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new control\r\n     * @param name defines the control name\r\n     */\r\n    constructor(\r\n        /** Defines the control name */\r\n        public name?: string\r\n    ) {}\r\n\r\n    /**\r\n     * Gets a string representing the class name\r\n     */\r\n    public get typeName(): string {\r\n        return this._getTypeName();\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the control.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return this._getTypeName();\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Control3D\";\r\n    }\r\n\r\n    /**\r\n     * Gets the transform node used by this control\r\n     */\r\n    public get node(): Nullable<TransformNode> {\r\n        return this._node;\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh used to render this control\r\n     */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        if (this._node instanceof AbstractMesh) {\r\n            return this._node as AbstractMesh;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Link the control as child of the given node\r\n     * @param node defines the node to link to. Use null to unlink the control\r\n     * @returns the current control\r\n     */\r\n    public linkToTransformNode(node: Nullable<TransformNode>): Control3D {\r\n        if (this._node) {\r\n            this._node.parent = node;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _prepareNode(scene: Scene): void {\r\n        if (!this._node) {\r\n            this._node = this._createNode(scene);\r\n\r\n            if (!this.node) {\r\n                return;\r\n            }\r\n            this._injectGUI3DReservedDataStore(this.node).control = this; // Store the control on the reservedDataStore field in order to get it when picking\r\n\r\n            const mesh = this.mesh;\r\n            if (mesh) {\r\n                mesh.isPickable = true;\r\n\r\n                this._affectMaterial(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _injectGUI3DReservedDataStore(node: TransformNode): any {\r\n        node.reservedDataStore = node.reservedDataStore ?? {};\r\n        node.reservedDataStore.GUI3D = node.reservedDataStore.GUI3D ?? {};\r\n        return node.reservedDataStore.GUI3D;\r\n    }\r\n\r\n    /**\r\n     * Node creation.\r\n     * Can be overriden by children\r\n     * @param scene defines the scene where the node must be attached\r\n     * @returns the attached node or null if none. Must return a Mesh or AbstractMesh if there is an attached visible object\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _createNode(scene: Scene): Nullable<TransformNode> {\r\n        // Do nothing by default\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Affect a material to the given mesh\r\n     * @param mesh defines the mesh which will represent the control\r\n     */\r\n    protected _affectMaterial(mesh: AbstractMesh) {\r\n        mesh.material = null;\r\n    }\r\n\r\n    private _isTouchButton3D(control: Control3D): control is TouchButton3D {\r\n        return (control as TouchButton3D)._generatePointerEventType !== undefined;\r\n    }\r\n\r\n    // Pointers\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerMove(target: Control3D, coordinates: Vector3): void {\r\n        this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerEnter(target: Control3D): boolean {\r\n        if (this._enterCount === -1) {\r\n            // -1 is for touch input, we are now sure we are with a mouse or pencil\r\n            this._enterCount = 0;\r\n        }\r\n\r\n        this._enterCount++;\r\n\r\n        if (this._enterCount > 1) {\r\n            return false;\r\n        }\r\n\r\n        this.onPointerEnterObservable.notifyObservers(this, -1, target, this);\r\n\r\n        if (this.pointerEnterAnimation) {\r\n            this.pointerEnterAnimation();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerOut(target: Control3D): void {\r\n        this._enterCount--;\r\n\r\n        if (this._enterCount > 0) {\r\n            return;\r\n        }\r\n\r\n        this._enterCount = 0;\r\n\r\n        this.onPointerOutObservable.notifyObservers(this, -1, target, this);\r\n\r\n        if (this.pointerOutAnimation) {\r\n            this.pointerOutAnimation();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerDown(target: Control3D, coordinates: Vector3, pointerId: number, buttonIndex: number): boolean {\r\n        this._downCount++;\r\n        this._downPointerIds[pointerId] = this._downPointerIds[pointerId] + 1 || 1;\r\n\r\n        if (this._downCount !== 1) {\r\n            return false;\r\n        }\r\n\r\n        this.onPointerDownObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\r\n\r\n        if (this.pointerDownAnimation) {\r\n            this.pointerDownAnimation();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _onPointerUp(target: Control3D, coordinates: Vector3, pointerId: number, buttonIndex: number, notifyClick: boolean): void {\r\n        this._downCount--;\r\n        this._downPointerIds[pointerId]--;\r\n\r\n        if (this._downPointerIds[pointerId] <= 0) {\r\n            delete this._downPointerIds[pointerId];\r\n        }\r\n\r\n        if (this._downCount < 0) {\r\n            // Handle if forcePointerUp was called prior to this\r\n            this._downCount = 0;\r\n            return;\r\n        }\r\n\r\n        if (this._downCount == 0) {\r\n            if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {\r\n                this.onPointerClickObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\r\n            }\r\n            this.onPointerUpObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);\r\n\r\n            if (this.pointerUpAnimation) {\r\n                this.pointerUpAnimation();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public forcePointerUp(pointerId: Nullable<number> = null) {\r\n        if (pointerId !== null) {\r\n            this._onPointerUp(this, Vector3.Zero(), pointerId, 0, true);\r\n        } else {\r\n            for (const key in this._downPointerIds) {\r\n                this._onPointerUp(this, Vector3.Zero(), +key as number, 0, true);\r\n            }\r\n            if (this._downCount > 0) {\r\n                this._downCount = 1;\r\n                this._onPointerUp(this, Vector3.Zero(), 0, 0, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _processObservables(type: number, pickedPoint: Vector3, originMeshPosition: Nullable<Vector3>, pointerId: number, buttonIndex: number): boolean {\r\n        if (this._isTouchButton3D(this) && originMeshPosition) {\r\n            type = this._generatePointerEventType(type, originMeshPosition, this._downCount);\r\n        }\r\n\r\n        if (type === PointerEventTypes.POINTERMOVE) {\r\n            this._onPointerMove(this, pickedPoint);\r\n\r\n            const previousControlOver = this._host._lastControlOver[pointerId];\r\n            if (previousControlOver && previousControlOver !== this) {\r\n                previousControlOver._onPointerOut(this);\r\n            }\r\n\r\n            if (previousControlOver !== this) {\r\n                this._onPointerEnter(this);\r\n            }\r\n\r\n            this._host._lastControlOver[pointerId] = this;\r\n            return true;\r\n        }\r\n\r\n        if (type === PointerEventTypes.POINTERDOWN) {\r\n            this._onPointerDown(this, pickedPoint, pointerId, buttonIndex);\r\n            this._host._lastControlDown[pointerId] = this;\r\n            this._host._lastPickedControl = this;\r\n            return true;\r\n        }\r\n\r\n        if (type === PointerEventTypes.POINTERUP || type === PointerEventTypes.POINTERDOUBLETAP) {\r\n            if (this._host._lastControlDown[pointerId]) {\r\n                this._host._lastControlDown[pointerId]._onPointerUp(this, pickedPoint, pointerId, buttonIndex, true);\r\n            }\r\n            delete this._host._lastControlDown[pointerId];\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _disposeNode(): void {\r\n        if (this._node) {\r\n            this._node.dispose();\r\n            this._node = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        this.onPointerDownObservable.clear();\r\n        this.onPointerEnterObservable.clear();\r\n        this.onPointerMoveObservable.clear();\r\n        this.onPointerOutObservable.clear();\r\n        this.onPointerUpObservable.clear();\r\n        this.onPointerClickObservable.clear();\r\n\r\n        this._disposeNode();\r\n\r\n        // Behaviors\r\n        for (const behavior of this._behaviors) {\r\n            behavior.detach();\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Control3D } from \"./control3D\";\r\n\r\n/**\r\n * Class used to create containers for controls\r\n */\r\nexport class Container3D extends Control3D {\r\n    private _blockLayout = false;\r\n\r\n    /**\r\n     * Gets the list of child controls\r\n     */\r\n    protected _children = new Array<Control3D>();\r\n\r\n    /**\r\n     * Gets the list of child controls\r\n     */\r\n    public get children(): Array<Control3D> {\r\n        return this._children;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the layout must be blocked (default is false).\r\n     * This is helpful to optimize layout operation when adding multiple children in a row\r\n     */\r\n    public get blockLayout(): boolean {\r\n        return this._blockLayout;\r\n    }\r\n\r\n    public set blockLayout(value: boolean) {\r\n        if (this._blockLayout === value) {\r\n            return;\r\n        }\r\n\r\n        this._blockLayout = value;\r\n\r\n        if (!this._blockLayout) {\r\n            this._arrangeChildren();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new container\r\n     * @param name defines the container name\r\n     */\r\n    constructor(name?: string) {\r\n        super(name);\r\n    }\r\n\r\n    /**\r\n     * Force the container to update the layout. Please note that it will not take blockLayout property in account\r\n     * @returns the current container\r\n     */\r\n    public updateLayout(): Container3D {\r\n        this._arrangeChildren();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given control is in the children of this control\r\n     * @param control defines the control to check\r\n     * @returns true if the control is in the child list\r\n     */\r\n    public containsControl(control: Control3D): boolean {\r\n        return this._children.indexOf(control) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Adds a control to the children of this control\r\n     * @param control defines the control to add\r\n     * @returns the current container\r\n     */\r\n    public addControl(control: Control3D): Container3D {\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            return this;\r\n        }\r\n        control.parent = this;\r\n        control._host = this._host;\r\n\r\n        this._children.push(control);\r\n\r\n        if (this._host.utilityLayer) {\r\n            control._prepareNode(this._host.utilityLayer.utilityLayerScene);\r\n\r\n            if (control.node) {\r\n                control.node.parent = this.node;\r\n            }\r\n\r\n            if (!this.blockLayout) {\r\n                this._arrangeChildren();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * This function will be called everytime a new control is added\r\n     */\r\n    protected _arrangeChildren() {}\r\n\r\n    protected _createNode(scene: Scene): Nullable<TransformNode> {\r\n        return new TransformNode(\"ContainerNode\", scene);\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the children of this control\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public removeControl(control: Control3D): Container3D {\r\n        const index = this._children.indexOf(control);\r\n\r\n        if (index !== -1) {\r\n            this._children.splice(index, 1);\r\n\r\n            control.parent = null;\r\n            control._disposeNode();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _getTypeName(): string {\r\n        return \"Container3D\";\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        for (const control of this._children) {\r\n            control.dispose();\r\n        }\r\n\r\n        this._children.length = 0;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /** Control rotation will remain unchanged  */\r\n    public static readonly UNSET_ORIENTATION = 0;\r\n\r\n    /** Control will rotate to make it look at sphere central axis */\r\n    public static readonly FACEORIGIN_ORIENTATION = 1;\r\n\r\n    /** Control will rotate to make it look back at sphere central axis */\r\n    public static readonly FACEORIGINREVERSED_ORIENTATION = 2;\r\n\r\n    /** Control will rotate to look at z axis (0, 0, 1) */\r\n    public static readonly FACEFORWARD_ORIENTATION = 3;\r\n\r\n    /** Control will rotate to look at negative z axis (0, 0, -1) */\r\n    public static readonly FACEFORWARDREVERSED_ORIENTATION = 4;\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport type { PointerInfo } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { UtilityLayerRenderer } from \"core/Rendering/utilityLayerRenderer\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\nimport type { IDisposable, Scene } from \"core/scene\";\r\n\r\nimport { Container3D } from \"./controls/container3D\";\r\nimport type { Control3D } from \"./controls/control3D\";\r\nimport type { IPointerEvent } from \"core/Events/deviceInputEvents\";\r\n\r\n/**\r\n * Class used to manage 3D user interface\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui3D\r\n */\r\nexport class GUI3DManager implements IDisposable {\r\n    private _scene: Scene;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _utilityLayer: Nullable<UtilityLayerRenderer>;\r\n    private _rootContainer: Container3D;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _pointerOutObserver: Nullable<Observer<number>>;\r\n    private _customControlScaling = 1.0;\r\n    /** @internal */\r\n    public _lastPickedControl: Control3D;\r\n    /** @internal */\r\n    public _lastControlOver: { [pointerId: number]: Control3D } = {};\r\n    /** @internal */\r\n    public _lastControlDown: { [pointerId: number]: Control3D } = {};\r\n\r\n    protected static MRTK_REALISTIC_SCALING: number = 0.032;\r\n\r\n    /**\r\n     * Observable raised when the point picked by the pointer events changed\r\n     */\r\n    public onPickedPointChangedObservable = new Observable<Nullable<Vector3>>();\r\n\r\n    /**\r\n     * Observable raised when a picking happens\r\n     */\r\n    public onPickingObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    // Shared resources\r\n    /** @internal */\r\n    public _sharedMaterials: { [key: string]: Material } = {};\r\n\r\n    /** @internal */\r\n    public _touchSharedMaterials: { [key: string]: Material } = {};\r\n\r\n    /** Gets the hosting scene */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** Gets associated utility layer */\r\n    public get utilityLayer(): Nullable<UtilityLayerRenderer> {\r\n        return this._utilityLayer;\r\n    }\r\n\r\n    /** Gets the scaling for all UI elements owned by this manager */\r\n    public get controlScaling() {\r\n        return this._customControlScaling;\r\n    }\r\n\r\n    /** Sets the scaling adjustment for all UI elements owned by this manager */\r\n    public set controlScaling(newScale: number) {\r\n        if (this._customControlScaling !== newScale && newScale > 0) {\r\n            const scaleRatio = newScale / this._customControlScaling;\r\n            this._customControlScaling = newScale;\r\n\r\n            this._rootContainer.children.forEach((control: Control3D) => {\r\n                control.scaling.scaleInPlace(scaleRatio);\r\n\r\n                if (newScale !== 1) {\r\n                    control._isScaledByManager = true;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Gets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */\r\n    public get useRealisticScaling() {\r\n        return this.controlScaling === GUI3DManager.MRTK_REALISTIC_SCALING;\r\n    }\r\n\r\n    /** Sets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */\r\n    public set useRealisticScaling(newValue: boolean) {\r\n        this.controlScaling = newValue ? GUI3DManager.MRTK_REALISTIC_SCALING : 1;\r\n    }\r\n\r\n    /**\r\n     * Creates a new GUI3DManager\r\n     * @param scene\r\n     */\r\n    public constructor(scene?: Scene) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\r\n            this._sceneDisposeObserver = null;\r\n            this._utilityLayer = null;\r\n            this.dispose();\r\n        });\r\n\r\n        this._utilityLayer = UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(this._scene);\r\n        this._utilityLayer.onlyCheckPointerDownEvents = false;\r\n        this._utilityLayer.pickUtilitySceneFirst = false;\r\n        this._utilityLayer.mainSceneTrackerPredicate = (mesh: Nullable<AbstractMesh>) => {\r\n            return mesh && mesh.reservedDataStore?.GUI3D?.control?._node;\r\n        };\r\n\r\n        // Root\r\n        this._rootContainer = new Container3D(\"RootContainer\");\r\n        this._rootContainer._host = this;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        // Events\r\n        this._pointerOutObserver = this._utilityLayer.onPointerOutObservable.add((pointerId) => {\r\n            this._handlePointerOut(pointerId, true);\r\n        });\r\n\r\n        this._pointerObserver = utilityLayerScene.onPointerObservable.add((pi) => {\r\n            this._doPicking(pi);\r\n        });\r\n\r\n        // Scene\r\n        this._utilityLayer.utilityLayerScene.autoClear = false;\r\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n        new HemisphericLight(\"hemi\", Vector3.Up(), this._utilityLayer.utilityLayerScene);\r\n    }\r\n\r\n    private _handlePointerOut(pointerId: number, isPointerUp: boolean) {\r\n        const previousControlOver = this._lastControlOver[pointerId];\r\n        if (previousControlOver) {\r\n            previousControlOver._onPointerOut(previousControlOver);\r\n            delete this._lastControlOver[pointerId];\r\n        }\r\n\r\n        if (isPointerUp) {\r\n            if (this._lastControlDown[pointerId]) {\r\n                this._lastControlDown[pointerId].forcePointerUp();\r\n                delete this._lastControlDown[pointerId];\r\n            }\r\n        }\r\n\r\n        this.onPickedPointChangedObservable.notifyObservers(null);\r\n    }\r\n\r\n    private _doPicking(pi: PointerInfo): boolean {\r\n        if (!this._utilityLayer || !this._utilityLayer.shouldRender || !this._utilityLayer.utilityLayerScene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const pointerEvent = <IPointerEvent>pi.event;\r\n\r\n        const pointerId = pointerEvent.pointerId || 0;\r\n        const buttonIndex = pointerEvent.button;\r\n\r\n        const pickingInfo = pi.pickInfo;\r\n        if (pickingInfo) {\r\n            this.onPickingObservable.notifyObservers(pickingInfo.pickedMesh);\r\n        }\r\n\r\n        if (!pickingInfo || !pickingInfo.hit) {\r\n            this._handlePointerOut(pointerId, pi.type === PointerEventTypes.POINTERUP);\r\n            return false;\r\n        }\r\n\r\n        if (pickingInfo.pickedPoint) {\r\n            this.onPickedPointChangedObservable.notifyObservers(pickingInfo.pickedPoint);\r\n        }\r\n\r\n        const control = <Control3D>pickingInfo.pickedMesh!.reservedDataStore?.GUI3D?.control;\r\n        if (!!control && !control._processObservables(pi.type, pickingInfo.pickedPoint!, pickingInfo.originMesh?.position || null, pointerId, buttonIndex)) {\r\n            if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId]);\r\n                }\r\n\r\n                delete this._lastControlOver[pointerId];\r\n            }\r\n        }\r\n\r\n        if (pi.type === PointerEventTypes.POINTERUP) {\r\n            if (this._lastControlDown[pointerEvent.pointerId]) {\r\n                this._lastControlDown[pointerEvent.pointerId].forcePointerUp();\r\n                delete this._lastControlDown[pointerEvent.pointerId];\r\n            }\r\n\r\n            if (pointerEvent.pointerType === \"touch\" || (pointerEvent.pointerType === \"xr\" && this._scene.getEngine().hostInformation.isMobile)) {\r\n                this._handlePointerOut(pointerId, false);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the root container\r\n     */\r\n    public get rootContainer(): Container3D {\r\n        return this._rootContainer;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the given control is in the root child list\r\n     * @param control defines the control to check\r\n     * @returns true if the control is in the root child list\r\n     */\r\n    public containsControl(control: Control3D): boolean {\r\n        return this._rootContainer.containsControl(control);\r\n    }\r\n\r\n    /**\r\n     * Adds a control to the root child list\r\n     * @param control defines the control to add\r\n     * @returns the current manager\r\n     */\r\n    public addControl(control: Control3D): GUI3DManager {\r\n        this._rootContainer.addControl(control);\r\n        if (this._customControlScaling !== 1) {\r\n            control.scaling.scaleInPlace(this._customControlScaling);\r\n            control._isScaledByManager = true;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes a control from the root child list\r\n     * @param control defines the control to remove\r\n     * @returns the current container\r\n     */\r\n    public removeControl(control: Control3D): GUI3DManager {\r\n        this._rootContainer.removeControl(control);\r\n        if (control._isScaledByManager) {\r\n            control.scaling.scaleInPlace(1 / this._customControlScaling);\r\n            control._isScaledByManager = false;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose() {\r\n        this._rootContainer.dispose();\r\n\r\n        for (const materialName in this._sharedMaterials) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._sharedMaterials, materialName)) {\r\n                continue;\r\n            }\r\n\r\n            this._sharedMaterials[materialName].dispose();\r\n        }\r\n\r\n        this._sharedMaterials = {};\r\n\r\n        for (const materialName in this._touchSharedMaterials) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._touchSharedMaterials, materialName)) {\r\n                continue;\r\n            }\r\n\r\n            this._touchSharedMaterials[materialName].dispose();\r\n        }\r\n\r\n        this._touchSharedMaterials = {};\r\n\r\n        if (this._pointerOutObserver && this._utilityLayer) {\r\n            this._utilityLayer.onPointerOutObservable.remove(this._pointerOutObserver);\r\n            this._pointerOutObserver = null;\r\n        }\r\n\r\n        this.onPickedPointChangedObservable.clear();\r\n        this.onPickingObservable.clear();\r\n\r\n        const utilityLayerScene = this._utilityLayer ? this._utilityLayer.utilityLayerScene : null;\r\n\r\n        if (utilityLayerScene) {\r\n            if (this._pointerObserver) {\r\n                utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n                this._pointerObserver = null;\r\n            }\r\n        }\r\n        if (this._scene) {\r\n            if (this._sceneDisposeObserver) {\r\n                this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n                this._sceneDisposeObserver = null;\r\n            }\r\n        }\r\n\r\n        if (this._utilityLayer) {\r\n            this._utilityLayer.dispose();\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
