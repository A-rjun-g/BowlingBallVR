import {
  UtilityLayerRenderer
} from "./chunk-PI2XYCZQ.js";
import {
  AbstractMesh,
  EngineStore,
  HemisphericLight,
  Observable,
  PointerEventTypes,
  TransformNode,
  Vector3
} from "./chunk-ZAXYU4XE.js";

// node_modules/@babylonjs/gui/3D/vector3WithInfo.js
var Vector3WithInfo = class extends Vector3 {
  /**
   * Creates a new Vector3WithInfo
   * @param source defines the vector3 data to transport
   * @param buttonIndex defines the current mouse button index
   */
  constructor(source, buttonIndex = 0) {
    super(source.x, source.y, source.z);
    this.buttonIndex = buttonIndex;
  }
};

// node_modules/@babylonjs/gui/3D/controls/control3D.js
var Control3D = class {
  /** Gets or sets the control position in world space */
  get position() {
    if (!this._node) {
      return Vector3.Zero();
    }
    return this._node.position;
  }
  set position(value) {
    if (!this._node) {
      return;
    }
    this._node.position = value;
  }
  /** Gets or sets the control scaling in world space */
  get scaling() {
    if (!this._node) {
      return new Vector3(1, 1, 1);
    }
    return this._node.scaling;
  }
  set scaling(value) {
    if (!this._node) {
      return;
    }
    this._isScaledByManager = false;
    this._node.scaling = value;
  }
  /**
   * Gets the list of attached behaviors
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   */
  get behaviors() {
    return this._behaviors;
  }
  /**
   * Attach a behavior to the control
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current control
   */
  addBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    const scene = this._host.scene;
    if (scene.isLoading) {
      scene.onDataLoadedObservable.addOnce(() => {
        behavior.attach(this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  }
  /**
   * Remove an attached behavior
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current control
   */
  removeBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  }
  /**
   * Gets an attached behavior by name
   * @param name defines the name of the behavior to look for
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @returns null if behavior was not found else the requested behavior
   */
  getBehaviorByName(name) {
    for (const behavior of this._behaviors) {
      if (behavior.name === name) {
        return behavior;
      }
    }
    return null;
  }
  /** Gets or sets a boolean indicating if the control is visible */
  get isVisible() {
    return this._isVisible;
  }
  set isVisible(value) {
    if (this._isVisible === value) {
      return;
    }
    this._isVisible = value;
    const mesh = this.mesh;
    if (mesh) {
      mesh.setEnabled(value);
    }
  }
  /**
   * Creates a new control
   * @param name defines the control name
   */
  constructor(name) {
    this.name = name;
    this._downCount = 0;
    this._enterCount = -1;
    this._downPointerIds = {};
    this._isVisible = true;
    this._isScaledByManager = false;
    this.onPointerMoveObservable = new Observable();
    this.onPointerOutObservable = new Observable();
    this.onPointerDownObservable = new Observable();
    this.onPointerUpObservable = new Observable();
    this.onPointerClickObservable = new Observable();
    this.onPointerEnterObservable = new Observable();
    this._behaviors = new Array();
  }
  /**
   * Gets a string representing the class name
   */
  get typeName() {
    return this._getTypeName();
  }
  /**
   * Get the current class name of the control.
   * @returns current class name
   */
  getClassName() {
    return this._getTypeName();
  }
  _getTypeName() {
    return "Control3D";
  }
  /**
   * Gets the transform node used by this control
   */
  get node() {
    return this._node;
  }
  /**
   * Gets the mesh used to render this control
   */
  get mesh() {
    if (this._node instanceof AbstractMesh) {
      return this._node;
    }
    return null;
  }
  /**
   * Link the control as child of the given node
   * @param node defines the node to link to. Use null to unlink the control
   * @returns the current control
   */
  linkToTransformNode(node) {
    if (this._node) {
      this._node.parent = node;
    }
    return this;
  }
  /**
   * @internal
   */
  _prepareNode(scene) {
    if (!this._node) {
      this._node = this._createNode(scene);
      if (!this.node) {
        return;
      }
      this._injectGUI3DReservedDataStore(this.node).control = this;
      const mesh = this.mesh;
      if (mesh) {
        mesh.isPickable = true;
        this._affectMaterial(mesh);
      }
    }
  }
  _injectGUI3DReservedDataStore(node) {
    node.reservedDataStore = node.reservedDataStore ?? {};
    node.reservedDataStore.GUI3D = node.reservedDataStore.GUI3D ?? {};
    return node.reservedDataStore.GUI3D;
  }
  /**
   * Node creation.
   * Can be overriden by children
   * @param scene defines the scene where the node must be attached
   * @returns the attached node or null if none. Must return a Mesh or AbstractMesh if there is an attached visible object
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _createNode(scene) {
    return null;
  }
  /**
   * Affect a material to the given mesh
   * @param mesh defines the mesh which will represent the control
   */
  _affectMaterial(mesh) {
    mesh.material = null;
  }
  _isTouchButton3D(control) {
    return control._generatePointerEventType !== void 0;
  }
  // Pointers
  /**
   * @internal
   */
  _onPointerMove(target, coordinates) {
    this.onPointerMoveObservable.notifyObservers(coordinates, -1, target, this);
  }
  /**
   * @internal
   */
  _onPointerEnter(target) {
    if (this._enterCount === -1) {
      this._enterCount = 0;
    }
    this._enterCount++;
    if (this._enterCount > 1) {
      return false;
    }
    this.onPointerEnterObservable.notifyObservers(this, -1, target, this);
    if (this.pointerEnterAnimation) {
      this.pointerEnterAnimation();
    }
    return true;
  }
  /**
   * @internal
   */
  _onPointerOut(target) {
    this._enterCount--;
    if (this._enterCount > 0) {
      return;
    }
    this._enterCount = 0;
    this.onPointerOutObservable.notifyObservers(this, -1, target, this);
    if (this.pointerOutAnimation) {
      this.pointerOutAnimation();
    }
  }
  /**
   * @internal
   */
  _onPointerDown(target, coordinates, pointerId, buttonIndex) {
    this._downCount++;
    this._downPointerIds[pointerId] = this._downPointerIds[pointerId] + 1 || 1;
    if (this._downCount !== 1) {
      return false;
    }
    this.onPointerDownObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
    if (this.pointerDownAnimation) {
      this.pointerDownAnimation();
    }
    return true;
  }
  /**
   * @internal
   */
  _onPointerUp(target, coordinates, pointerId, buttonIndex, notifyClick) {
    this._downCount--;
    this._downPointerIds[pointerId]--;
    if (this._downPointerIds[pointerId] <= 0) {
      delete this._downPointerIds[pointerId];
    }
    if (this._downCount < 0) {
      this._downCount = 0;
      return;
    }
    if (this._downCount == 0) {
      if (notifyClick && (this._enterCount > 0 || this._enterCount === -1)) {
        this.onPointerClickObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      }
      this.onPointerUpObservable.notifyObservers(new Vector3WithInfo(coordinates, buttonIndex), -1, target, this);
      if (this.pointerUpAnimation) {
        this.pointerUpAnimation();
      }
    }
  }
  /**
   * @internal
   */
  forcePointerUp(pointerId = null) {
    if (pointerId !== null) {
      this._onPointerUp(this, Vector3.Zero(), pointerId, 0, true);
    } else {
      for (const key in this._downPointerIds) {
        this._onPointerUp(this, Vector3.Zero(), +key, 0, true);
      }
      if (this._downCount > 0) {
        this._downCount = 1;
        this._onPointerUp(this, Vector3.Zero(), 0, 0, true);
      }
    }
  }
  /**
   * @internal
   */
  _processObservables(type, pickedPoint, originMeshPosition, pointerId, buttonIndex) {
    if (this._isTouchButton3D(this) && originMeshPosition) {
      type = this._generatePointerEventType(type, originMeshPosition, this._downCount);
    }
    if (type === PointerEventTypes.POINTERMOVE) {
      this._onPointerMove(this, pickedPoint);
      const previousControlOver = this._host._lastControlOver[pointerId];
      if (previousControlOver && previousControlOver !== this) {
        previousControlOver._onPointerOut(this);
      }
      if (previousControlOver !== this) {
        this._onPointerEnter(this);
      }
      this._host._lastControlOver[pointerId] = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERDOWN) {
      this._onPointerDown(this, pickedPoint, pointerId, buttonIndex);
      this._host._lastControlDown[pointerId] = this;
      this._host._lastPickedControl = this;
      return true;
    }
    if (type === PointerEventTypes.POINTERUP || type === PointerEventTypes.POINTERDOUBLETAP) {
      if (this._host._lastControlDown[pointerId]) {
        this._host._lastControlDown[pointerId]._onPointerUp(this, pickedPoint, pointerId, buttonIndex, true);
      }
      delete this._host._lastControlDown[pointerId];
      return true;
    }
    return false;
  }
  /** @internal */
  _disposeNode() {
    if (this._node) {
      this._node.dispose();
      this._node = null;
    }
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    this.onPointerDownObservable.clear();
    this.onPointerEnterObservable.clear();
    this.onPointerMoveObservable.clear();
    this.onPointerOutObservable.clear();
    this.onPointerUpObservable.clear();
    this.onPointerClickObservable.clear();
    this._disposeNode();
    for (const behavior of this._behaviors) {
      behavior.detach();
    }
  }
};

// node_modules/@babylonjs/gui/3D/controls/container3D.js
var Container3D = class extends Control3D {
  /**
   * Gets the list of child controls
   */
  get children() {
    return this._children;
  }
  /**
   * Gets or sets a boolean indicating if the layout must be blocked (default is false).
   * This is helpful to optimize layout operation when adding multiple children in a row
   */
  get blockLayout() {
    return this._blockLayout;
  }
  set blockLayout(value) {
    if (this._blockLayout === value) {
      return;
    }
    this._blockLayout = value;
    if (!this._blockLayout) {
      this._arrangeChildren();
    }
  }
  /**
   * Creates a new container
   * @param name defines the container name
   */
  constructor(name) {
    super(name);
    this._blockLayout = false;
    this._children = new Array();
  }
  /**
   * Force the container to update the layout. Please note that it will not take blockLayout property in account
   * @returns the current container
   */
  updateLayout() {
    this._arrangeChildren();
    return this;
  }
  /**
   * Gets a boolean indicating if the given control is in the children of this control
   * @param control defines the control to check
   * @returns true if the control is in the child list
   */
  containsControl(control) {
    return this._children.indexOf(control) !== -1;
  }
  /**
   * Adds a control to the children of this control
   * @param control defines the control to add
   * @returns the current container
   */
  addControl(control) {
    const index = this._children.indexOf(control);
    if (index !== -1) {
      return this;
    }
    control.parent = this;
    control._host = this._host;
    this._children.push(control);
    if (this._host.utilityLayer) {
      control._prepareNode(this._host.utilityLayer.utilityLayerScene);
      if (control.node) {
        control.node.parent = this.node;
      }
      if (!this.blockLayout) {
        this._arrangeChildren();
      }
    }
    return this;
  }
  /**
   * This function will be called everytime a new control is added
   */
  _arrangeChildren() {
  }
  _createNode(scene) {
    return new TransformNode("ContainerNode", scene);
  }
  /**
   * Removes a control from the children of this control
   * @param control defines the control to remove
   * @returns the current container
   */
  removeControl(control) {
    const index = this._children.indexOf(control);
    if (index !== -1) {
      this._children.splice(index, 1);
      control.parent = null;
      control._disposeNode();
    }
    return this;
  }
  _getTypeName() {
    return "Container3D";
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    for (const control of this._children) {
      control.dispose();
    }
    this._children.length = 0;
    super.dispose();
  }
};
Container3D.UNSET_ORIENTATION = 0;
Container3D.FACEORIGIN_ORIENTATION = 1;
Container3D.FACEORIGINREVERSED_ORIENTATION = 2;
Container3D.FACEFORWARD_ORIENTATION = 3;
Container3D.FACEFORWARDREVERSED_ORIENTATION = 4;

// node_modules/@babylonjs/gui/3D/gui3DManager.js
var GUI3DManager = class _GUI3DManager {
  /** Gets the hosting scene */
  get scene() {
    return this._scene;
  }
  /** Gets associated utility layer */
  get utilityLayer() {
    return this._utilityLayer;
  }
  /** Gets the scaling for all UI elements owned by this manager */
  get controlScaling() {
    return this._customControlScaling;
  }
  /** Sets the scaling adjustment for all UI elements owned by this manager */
  set controlScaling(newScale) {
    if (this._customControlScaling !== newScale && newScale > 0) {
      const scaleRatio = newScale / this._customControlScaling;
      this._customControlScaling = newScale;
      this._rootContainer.children.forEach((control) => {
        control.scaling.scaleInPlace(scaleRatio);
        if (newScale !== 1) {
          control._isScaledByManager = true;
        }
      });
    }
  }
  /** Gets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
  get useRealisticScaling() {
    return this.controlScaling === _GUI3DManager.MRTK_REALISTIC_SCALING;
  }
  /** Sets if controls attached to this manager are realistically sized, based on the fact that 1 unit length is 1 meter */
  set useRealisticScaling(newValue) {
    this.controlScaling = newValue ? _GUI3DManager.MRTK_REALISTIC_SCALING : 1;
  }
  /**
   * Creates a new GUI3DManager
   * @param scene
   */
  constructor(scene) {
    this._customControlScaling = 1;
    this._lastControlOver = {};
    this._lastControlDown = {};
    this.onPickedPointChangedObservable = new Observable();
    this.onPickingObservable = new Observable();
    this._sharedMaterials = {};
    this._touchSharedMaterials = {};
    this._scene = scene || EngineStore.LastCreatedScene;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {
      this._sceneDisposeObserver = null;
      this._utilityLayer = null;
      this.dispose();
    });
    this._utilityLayer = UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(this._scene);
    this._utilityLayer.onlyCheckPointerDownEvents = false;
    this._utilityLayer.pickUtilitySceneFirst = false;
    this._utilityLayer.mainSceneTrackerPredicate = (mesh) => {
      var _a, _b, _c;
      return mesh && ((_c = (_b = (_a = mesh.reservedDataStore) == null ? void 0 : _a.GUI3D) == null ? void 0 : _b.control) == null ? void 0 : _c._node);
    };
    this._rootContainer = new Container3D("RootContainer");
    this._rootContainer._host = this;
    const utilityLayerScene = this._utilityLayer.utilityLayerScene;
    this._pointerOutObserver = this._utilityLayer.onPointerOutObservable.add((pointerId) => {
      this._handlePointerOut(pointerId, true);
    });
    this._pointerObserver = utilityLayerScene.onPointerObservable.add((pi) => {
      this._doPicking(pi);
    });
    this._utilityLayer.utilityLayerScene.autoClear = false;
    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;
    new HemisphericLight("hemi", Vector3.Up(), this._utilityLayer.utilityLayerScene);
  }
  _handlePointerOut(pointerId, isPointerUp) {
    const previousControlOver = this._lastControlOver[pointerId];
    if (previousControlOver) {
      previousControlOver._onPointerOut(previousControlOver);
      delete this._lastControlOver[pointerId];
    }
    if (isPointerUp) {
      if (this._lastControlDown[pointerId]) {
        this._lastControlDown[pointerId].forcePointerUp();
        delete this._lastControlDown[pointerId];
      }
    }
    this.onPickedPointChangedObservable.notifyObservers(null);
  }
  _doPicking(pi) {
    var _a, _b, _c;
    if (!this._utilityLayer || !this._utilityLayer.shouldRender || !this._utilityLayer.utilityLayerScene.activeCamera) {
      return false;
    }
    const pointerEvent = pi.event;
    const pointerId = pointerEvent.pointerId || 0;
    const buttonIndex = pointerEvent.button;
    const pickingInfo = pi.pickInfo;
    if (pickingInfo) {
      this.onPickingObservable.notifyObservers(pickingInfo.pickedMesh);
    }
    if (!pickingInfo || !pickingInfo.hit) {
      this._handlePointerOut(pointerId, pi.type === PointerEventTypes.POINTERUP);
      return false;
    }
    if (pickingInfo.pickedPoint) {
      this.onPickedPointChangedObservable.notifyObservers(pickingInfo.pickedPoint);
    }
    const control = (_b = (_a = pickingInfo.pickedMesh.reservedDataStore) == null ? void 0 : _a.GUI3D) == null ? void 0 : _b.control;
    if (!!control && !control._processObservables(pi.type, pickingInfo.pickedPoint, ((_c = pickingInfo.originMesh) == null ? void 0 : _c.position) || null, pointerId, buttonIndex)) {
      if (pi.type === PointerEventTypes.POINTERMOVE) {
        if (this._lastControlOver[pointerId]) {
          this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId]);
        }
        delete this._lastControlOver[pointerId];
      }
    }
    if (pi.type === PointerEventTypes.POINTERUP) {
      if (this._lastControlDown[pointerEvent.pointerId]) {
        this._lastControlDown[pointerEvent.pointerId].forcePointerUp();
        delete this._lastControlDown[pointerEvent.pointerId];
      }
      if (pointerEvent.pointerType === "touch" || pointerEvent.pointerType === "xr" && this._scene.getEngine().hostInformation.isMobile) {
        this._handlePointerOut(pointerId, false);
      }
    }
    return true;
  }
  /**
   * Gets the root container
   */
  get rootContainer() {
    return this._rootContainer;
  }
  /**
   * Gets a boolean indicating if the given control is in the root child list
   * @param control defines the control to check
   * @returns true if the control is in the root child list
   */
  containsControl(control) {
    return this._rootContainer.containsControl(control);
  }
  /**
   * Adds a control to the root child list
   * @param control defines the control to add
   * @returns the current manager
   */
  addControl(control) {
    this._rootContainer.addControl(control);
    if (this._customControlScaling !== 1) {
      control.scaling.scaleInPlace(this._customControlScaling);
      control._isScaledByManager = true;
    }
    return this;
  }
  /**
   * Removes a control from the root child list
   * @param control defines the control to remove
   * @returns the current container
   */
  removeControl(control) {
    this._rootContainer.removeControl(control);
    if (control._isScaledByManager) {
      control.scaling.scaleInPlace(1 / this._customControlScaling);
      control._isScaledByManager = false;
    }
    return this;
  }
  /**
   * Releases all associated resources
   */
  dispose() {
    this._rootContainer.dispose();
    for (const materialName in this._sharedMaterials) {
      if (!Object.prototype.hasOwnProperty.call(this._sharedMaterials, materialName)) {
        continue;
      }
      this._sharedMaterials[materialName].dispose();
    }
    this._sharedMaterials = {};
    for (const materialName in this._touchSharedMaterials) {
      if (!Object.prototype.hasOwnProperty.call(this._touchSharedMaterials, materialName)) {
        continue;
      }
      this._touchSharedMaterials[materialName].dispose();
    }
    this._touchSharedMaterials = {};
    if (this._pointerOutObserver && this._utilityLayer) {
      this._utilityLayer.onPointerOutObservable.remove(this._pointerOutObserver);
      this._pointerOutObserver = null;
    }
    this.onPickedPointChangedObservable.clear();
    this.onPickingObservable.clear();
    const utilityLayerScene = this._utilityLayer ? this._utilityLayer.utilityLayerScene : null;
    if (utilityLayerScene) {
      if (this._pointerObserver) {
        utilityLayerScene.onPointerObservable.remove(this._pointerObserver);
        this._pointerObserver = null;
      }
    }
    if (this._scene) {
      if (this._sceneDisposeObserver) {
        this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
        this._sceneDisposeObserver = null;
      }
    }
    if (this._utilityLayer) {
      this._utilityLayer.dispose();
    }
  }
};
GUI3DManager.MRTK_REALISTIC_SCALING = 0.032;

export {
  Vector3WithInfo,
  Control3D,
  Container3D,
  GUI3DManager
};
//# sourceMappingURL=chunk-KZ47ZJOF.js.map
